//! ======================================================МАССИВЫ=================================================

// Массив - структура данных для хранения и манипулирования коллекцией индексированных значений.
// Используeтся для хранения упорядоченных коллекций данных, например списка курортов, товаров, клиентов в отеле и т. п.

// Массив объявляется открывающей и закрывающей квадратной скобками [] - литералом массива.
// Внутри скобок каждый элемент массива разделяется запятой.

// const clients = ["Mango", "Poly", "Ajax"];

// Для доступа к значению элемента массива используется синтаксис квадратных скобок массив[индекс].
// Между именем переменной хранящей массив и квадратными скобками не должно быть пробела.

// const clients = ["Mango", "Poly", "Ajax"];

// Указывая в скобках индекс элемента мы получаем его значение
// console.log(clients[0]); // Mango
// console.log(clients[1]); // Poly
// console.log(clients[2]); // Ajax

// ?-----------------------------------------------Переопределение массива-----------------------------------------

// В отличии от строк, элементы массива можно изменять обратившись к ним по индексу и присвоив другое значение.

// const clients = ["Mango", "Poly", "Ajax"];
// clients[0] = "Kiwi";
// clients[1] = "Pango";
// console.log(clients); // ["Kiwi", "Pango", "Ajax"]

//? ---------------------------------------------------Длина массива------------------------------------------------

// Длина массива, то есть число его элементов, хранится в свойстве length. Это динамическая величина, которая изменяется автоматически при добавлении или удалении элементов.

// const clients = ["Mango", "Poly", "Ajax"];
// console.log(clients.length); // 3

//? ----------------------------------------------Индекс последнего элемента------------------------------------------------

// Чаще всего мы заранее в коде не знаем какая будет длина массива. Для того чтобы получить значение последнего элемента применяется следующий подход - длина массива всегда на единицу больше чем индекс последнего элемента. Используя формулу длина_массива - 1 можно получить значение последнего элемента массива произвольной длины.

// const clients = ["Mango", "Poly", "Ajax"];
// const lastElementIndex = clients.length - 1;
// console.log(lastElementIndex); // 2
// console.log(clients[lastElementIndex]); // "Ajax"

//!====================================================Методы массива==========================================

//* 1 .push - добавляет один или несколько элементов в конец массива

//* 2 .pop - удаляет последний элемент массива

//* 3 .unshift -  добавляет один или несколько элементов в начало массива

//* 4 .shift - удаляет первый элемент массива

//* 5 .reverce - изменяет порядок следования элементов массива. Первый элемент массива становится последним, а последний — первым.

//* 6 .splice - позволяет добавлять, удалять, заменять элементы массива

//* 7 .slice - создаёт новый массив, в который копирует часть либо целый существующий массив

//* 8 .concat - создаёт новый массив, в который копирует данные из других массивов и дополнительные значения (в конце массива)

//* 9 .indexOf(item, from) - ищет элемент и возвращает индекс на котором был найден элемент

//* 10 .includes(item, from) - ищет элемент и возвращает true, если поиск успешен и false, если поиск не успешен

//* 11 .split - преобразовует строку в массив по заданному разделителю

//* 12 .join - преобразовует массив в строку по заданному разделителю

//* 13 .Array.isArray() - проверяет объект на соответствие массиву

//* 14 .forEach - метод массива который используется как замена циклов for и for...of при работе с коллекцией данных

//* 15 .find(element, index, arr) - возвращает первый найденный элемент, который подходит условию callback функции(функция вернула true). Если ни один элемент не подошёл по условию - возвращается (undefined).

//* 16 .findIndex(element, index, arr) - возвращает индекс первого найденного элемента, который подходит условию callback функции(функция вернула true). Если ни один элемент не подошёл по условию - возвращает (-1) .

//* 17 .filter(element, index, arr) - возвращает новый массив, который состоит только из тех элементов, которые прошли проверку колбэк функции (если функция вернула true - элемент будет в новом массиве, если falce - элемент отбрасывается).

//* 18 .map(element, index, arr) - возвращает новый массив той же длины, каждый элемент которого был изменён по условию коллбэк функии(то что функция возвращает при каждой итерации)

//* 19 .flat(depth) - принимает глубину вложений (цифра) возвращает новый массив, где вложенные подмассивы будут записаны в один массив

//* 20 .flatMap - аналогичен методу map(), но применяется когда многомерный массив который необходимо «разгладить»

//* 21 .every() - поэлементно перебирает оригинальный массив. Возвращает true если все элементы массива удовлетворяют условию

//* 22 .some() - поэлементно перебирает оригинальный массив. Возвращает true если хотя бы один элемент массива подходит

//* 23 .reduce() - используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата

//* 24 .sort() - изменяет и вовращает выходной массив, в котором были отсортированы элементы по возрастанию или по уменьшению или в алфавитном порядке и т. п.

//* 25 .toString() - соединяет массив и возвращает одну строку, содержащую каждый элемент массива, разделённый запятыми.

// ?-----------Методы, мутирующие(изменяющие) массив и их альтернативные анлоги, не мутирующие(изменяющие) массив---------

// copyWithin() -     аналогов нет
// fill() -           аналогов нет
// pop() -            slice(0, -1)
// push(v1, v2) -     concat([v1,v2])
// reverse() -        toRewersed()
// shift() -          slice(1)
// sort() -           toSorted()
// splice() -         toSpliced()
// unshift(v1, v2) -  toSpliced{0, 0, v1, v2}

// ?---------------------------------------------------// 1 Метод push ----------------------------------------

// Добавляет один или несколько элементов в конец массива

// let arr = ['Ваня', 'Иштван', 'Оля'];
// arr.push('Вася');
// console.log(arr);
// arr.push('Дима', 'Катя');
// console.log(arr);

//? ----------------------------------------------------// 2 Метод pop --------------------------------------------

// удаляет последний элемент массива

// let arr = ['Ваня', 'Иштван', 'Оля'];
// arr.pop();
// console.log(arr);

// ?---------------------------------------------------// 3 Метод unshift ------------------------------------------

// добавляет один или несколько элементов в начало массива

// let arr = ['Ваня', 'Иштван', 'Оля'];
// arr.unshift('Вася');
// console.log(arr);
// arr.unshift('Дима', 'Катя');
// console.log(arr);

//? ---------------------------------------------------// 4 Метод shift----------------------------------------------

// удаляет первый элемент массива

// let arr = ['Ваня', 'Иштван', 'Оля'];
// arr.shift();
// console.log(arr);

//? ---------------------------------------------------// 5 Метод reverco-------------------------------------------

// изменяет порядок следования элементов массива (первый становится последним и наоборот)

// const myArray = ["один", "два", "три"];
// myArray.reverse();
// console.log(myArray); // ['три', 'два', 'один']

//? ---------------------------------------------------// 6 Метод splice-----------------------------------------------

// позволяет добавлять, удалять, заменять элементы массива

// Удаляем элемент

// let arrOne = ['Ваня', 'Иштван', 'Оля'];
// arrOne.splice(1, 1);
// console.log(arrOne);

// Удаляем элемент и возвращаем его в переменную

// let arrTwo = ['Ваня', 'Иштван', 'Оля'];
// let removed = arrTwo.splice(1, 1);
// console.log(removed);

// Заменяем элементы

// let arrThree = ['Ваня', 'Иштван', 'Оля'];
// arrThree.splice(0, 1, 'Коля');
// console.log(arrThree);

// Добавляем элементы

// let arrFour = ['Ваня', 'Иштван', 'Оля'];
// arrFour.splice(1, 0, 'Коля', 'Маша');
// console.log(arrFour);

// Удаляем элемент в конце массива

// let arrFive = ['Ваня', 'Иштван', 'Оля'];
// arrFive.splice(-1, 1);
// console.log(arrFive);

//?---------------------------------------------------// 7 Метод slice---------------------------------------

// создаёт новый массив, в который копирует часть либо целый существующий массив

// let arrOne = ['Ваня', 'Иштван', 'Оля'];
// let arrTwo = arrOne.slice(1, 2);
// console.log(arrTwo);

// let arrOne = ['Ваня', 'Иштван', 'Оля'];
// let arrTwo = arrOne.slice(1, 3);
// console.log(arrTwo);

// let arrOne = ['Ваня', 'Иштван', 'Оля'];
// let arrTwo = arrOne.slice();
// console.log(arrTwo);

// let arrOne = ['Ваня', 'Иштван', 'Оля'];
// let arrTwo = arrOne.slice();
// console.log(arrTwo);

// ?--------------------------------------------------// 8 Метод concat -----------------------------------------------

// создаёт новый массив, в который копирует данные из других массивов и дополнительные значения (в конце массива)

// let arrOne = ['Ваня', 'Иштван', 'Оля'];
// let arrTwo = arrOne.concat('Петя');
// console.log(arrTwo);

// ?-------------------------------------------------// 9 Метод indexOf(item, from)----------------------------------------

// Ищет элемент/item,
// начиная с индекса/from и возвращает индекс на котором был найден элемент. В противном случае возвращает (-1). From (необязательный параметр): Это индекс, с которого начинается поиск элемента. Если этот параметр не указан, поиск начинается с начала массива или строки.

// let arr = ['Ваня', 'Иштван', 'Оля', 'Коля'];
// console.log(arr.indexOf('Иштван'));
// console.log(arr.indexOf('Вася'));
// console.log(arr.indexOf('Коля', 1));
// console.log(arr.indexOf('Оля'));

//? -------------------------------------------------// 10 Метод includes(item, from) ---------------------------------
//
// Ищет элемент/item, начиная с индекса/from и возвращает true, если поиск успешен и false, если поиск не успешен. From (необязательный параметр): Это индекс, с которого начинается поиск элемента. Если этот параметр не указан, поиск начинается с начала массива или строки.

// let arr = ['Ваня', 'Иштван', 'Оля', 'Коля'];

// console.log(arr.includes('Иштван')); //true
// console.log(arr.includes('Вася')); //false
// console.log(arr.includes('Коля', 1)); //true
// console.log(arr.includes('Оля')); //true

// ?----------------------------------------------------// 11 Метод split ------------------------------------------

// преобразовует строку в массив по заданному разделителю

// В данном примере разделителем является запятая

// let str = 'Ваня, Иштван, Оля, Коля';
// let arr = str.split(',');
// console.log(arr);

// В данном примере мы ограничиваем количество элементов в будущем массиве до 3 элементов

// let str = 'Ваня, Иштван, Оля, Коля';
// let arr = str.split(',', 3);
// console.log(arr);

//? ----------------------------------------------------// 12 Метод join --------------------------------------------

// преобразовует массив в строку по заданному разделителю

// let arr = ['Ваня, Иштван, Оля, Коля'];
// let str = arr.join(',');
// console.log(str);

// ?----------------------------------------------------// 13 Метод Array.isArray() ----------------------------------

// Проверяет объект на соответствие массиву

// Массивы не являются отдельным типом данных. Они являются объектом. Поэтому проверить на соответствие данного объекта массиву с помощью typeof не получится.

// let obj = {};
// let arr = [];

// Данная проверка не покажет где массив
// console.log(typeof obj);
// console.log(typeof arr);

// Данная проверка покажет где массив
// if (Array.isArray(arr)) {
//   console.log('Это массив !');
// } else {
//   console.log('Это не массив !');
// }

// if (Array.isArray(obj)) {
//   console.log('Это массив !');
// } else {
//   console.log('Это не массив !');
// }

// ?----------------------------------------------------// 14 Метод forEach ------------------------------------

// /Перебирающий метод массива который используется как замена циклов for и for...of при работе с коллекцией данных.

// Поэлементно перебирает массив.
// Вызызвает коллбек-функцию для каждого элемента массива.
// Ничего не возвращает.
// Аргументы коллбек-функции это значение текущего элемента element, его индекс index и сам исходный массив array. Объявлять можно только те параметры которые нужны, чаще всего это элемент, главное не забывать про их порядок.

// Классический for

// const numbers = [5, 10, 15, 20, 25];
// for (let i = 0; i < numbers.length; i += 1) {
//   console.log(`Индекс ${i}, значение ${numbers[i]}`);
// }

// Перебирающий forEach

// Пример 1:

// const numbers = [5, 10, 15, 20, 25];
// numbers.forEach(function (number, index) {
//   console.log(`Индекс ${index}, значение ${number}`);
// });

// Пример 2:

// const numbers = [5, 10, 15, 20, 25];

// numbers.forEach((number) => {
//   console.log(number * 2); // Выводит удвоенные значения каждого элемента массива
// });

// Единственным случаем, когда стоит использовать циклы for или for...of для перебора массива, это задачи с прерыванием выполнения цикла. Прервать выполнение метода forEach нельзя, он всегда перебирает массив до конца.

// ?---------------------------------------------------// 15 Метод find()---------------------------------------------------

// Если метод filter(callback) используется для поиска всех элементов удовлетворяющим условию, то метод find(callback) позволяет найти и вернуть первый подходящий элемент, после чего перебор массива прекращается. То есть он ищет до первого совпадения.

// массив.find((element, index, array) => {
// Тело коллбек-функции
// });

// Не изменяет оригинальный массив.
// Поэлементно перебирает оригинальный массив.
// Возвращает первый элемент удовлетворяющий условию, то есть когда коллбек возвращает true.
// Если ни один элемент не подошёл, то есть для всех элементов коллбек вернул false, метод возвращает undefined.
// Метод find() используется для одной задачи - поиска элемента по уникальному значению свойства. Например, поиск пользователя по почте, автомобиля по серийному номеру, книги по названию и т. п.

// const colorPickerOptions = [
//   { label: 'red', color: '#F44336' },
//   { label: 'green', color: '#4CAF50' },
//   { label: 'blue', color: '#2196F3' },
//   { label: 'pink', color: '#E91E63' },
//   { label: 'indigo', color: '#3F51B5' },
// ];

// console.log(colorPickerOptions.find((option) => option.label === 'blue')); // { label: 'blue', color: '#2196F3' }
// console.log(colorPickerOptions.find((option) => option.label === 'pink')); // { label: 'pink', color: '#E91E63' }
// console.log(colorPickerOptions.find((option) => option.label === 'white')); // undefined

// ?---------------------------------------------------// 16 Метод findIndex()----------------------------------------------

// Метод findIndex(callback) это современная замена методу indexOf(). Позволяет выполнять поиск по более сложным условиям чем просто равенство. Используется как для поиска в массиве примитивов, так и в массиве обьектов.

// массив.findIndex((element, index, array) => {
// Тело коллбек-функции
// });

// Не изменяет оригинальный массив.
// Поэлементно перебирает оригинальный массив.
// Возвращает индекс первого элемента удовлетворяющего условию, то есть когда коллбек возвращает true.
// Если ни один элемент не подошёл, то есть для всех элементов коллбек вернул false, метод возвращает -1.

// const colorPickerOptions = [
//   { label: 'red', color: '#F44336' },
//   { label: 'green', color: '#4CAF50' },
//   { label: 'blue', color: '#2196F3' },
//   { label: 'pink', color: '#E91E63' },
//   { label: 'indigo', color: '#3F51B5' },
// ];

// console.log(colorPickerOptions.findIndex((option) => option.label === 'blue')); // 2
// console.log(colorPickerOptions.findIndex((option) => option.label === 'pink')); // 3
// console.log(colorPickerOptions.findIndex((option) => option.label === 'white')); // -1

// ?--------------------------------------------------// 17 Метод filter()-------------------------------------------------

// Метод filter(callback) используется для единственной операции - фильтрации массива, то есть когда необходимо выбрать более одного элемента из коллекции по какому-то критерию.

// массив.filter((element, index, array) => {
// Тело коллбек-функции
// });

// Не изменяет оригинальный массив.
// Поэлементно перебирает оригинальный массив.
// Возвращает новый массив.
// Добавляет в возвращаемый массив элементы которые удовлетворяют условию коллбек-функции.
// Если коллбек вернул true элемент добавляется в возвращаемый массив.
// Если коллбек вернул false элемент не добавляется в возвращаемый массив.
// Если ни один элемент не удовлетворил условию, возвращает пустой массив.

// const values = [51, -3, 27, 21, -68, 42, -37];

// const positiveValues = values.filter(value => value >= 0);
// console.log(positiveValues); // [51, 27, 21, 42]

// const negativeValues = values.filter(value => value < 0);
// console.log(negativeValues); // [-3, -68, -37]

// const bigValues = values.filter(value => value > 1000);
// console.log(bigValues); // []

// Оригинальный массив не изменился
// console.log(values); // [51, -3, 27, 21, -68, 42, -37]

// То есть метод filter вызывает коллбек-функцию для каждого элемента исходного массива и если результат её выполнения true, текущий элемент добавляет в новый массив.

// ------Фильтрация уникальных элементов

// Используя метод filter() можно выполнить фильтрацию массива так, что в нём останутся только уникальные элементы. Этот приём работает только с массивом примитивных значений - не объектов.

// Вернёмся к группе студентов и массиву всех посещаемых предметов, которые мы получили методом flatMap().

// const students = [
//   { name: "Манго", courses: ["математика", "физика"] },
//   { name: "Поли", courses: ["информатика", "математика"] },
//   { name: "Киви", courses: ["физика", "биология"] },
// ];

// const allCourses = students.flatMap(student => student.courses);
// ['математика', 'физика', 'информатика', 'математика', 'физика', 'биология'];

// В переменной allCourses хранится массив всех посещаемых предметов, которые могут повторяться. Задача заключается в том, чтобы сделать новый массив, в котором будут только уникальные предметы, то есть без повторений.

// const uniqueCourses = allCourses.filter(
//   (course, index, array) => array.indexOf(course) === index
// );

// Используя array.indexOf(course) выполняем поиск первого совпадения текущего элемента course и получаем его индекс в оригинальном массиве всех курсов. В параметре index хранится индекс текущего элемента course при переборе массива методом filter.

// Если результат indexOf() и значение index равны - это уникальный элемент, потому что это первый раз когда такое значение встречается в массиве и на текущей итерации фильтр обрабатывает именно его.

// # Массив всех курсов
// ['математика', 'физика', 'информатика', 'математика', 'физика', 'биология'];

// Для элемента 'математика' под индексом 0:

// indexOf() вернёт 0, потому что ищет первое совпадение.
// Значение параметра index будет 0.
// Они равны, значит это уникальный элемент.
// Для элемента 'математика' под индексом 3:

// indexOf() вернёт 0, потому что ищет первое совпадение.
// Значение параметра index будет 3.
// Они не равны, значит это повторяющийся - не уникальный элемент

// ----------Массив объектов

// При работе с массивом объектов выполняется фильтрация по значению какого-то свойства. В результате получается новый массив отфильтрованных объектов.

// Например, есть массив студентов с баллами за тест. Необходимо отфильтровать лучших (балл выше 80), худших (балл ниже 50) и средних студентов (балл от 50 до 80).

// const LOW_SCORE = 50;
// const HIGH_SCORE = 80;
// const students = [
//   { name: "Манго", score: 83 },
//   { name: "Поли", score: 59 },
//   { name: "Аякс", score: 37 },
//   { name: "Киви", score: 94 },
//   { name: "Хьюстон", score: 64 },
// ];

// const best = students.filter(student => student.score >= HIGH_SCORE);
// console.log(best); // Массив объектов с именами Манго и Киви

// const worst = students.filter(student => student.score < LOW_SCORE);
// console.log(worst); // Массив с одним объектом Аякс

// В коллбек-функции удобно деструктуризировать свойства объекта
// const average = students.filter(
//   ({ score }) => score >= LOW_SCORE && score < HIGH_SCORE
// );
// console.log(average); // Массив объектов с именами Поли и Хьюстон

// ?-------------------------------------------------// 18 Метод map() ------------------------------------------

// Метод map(callback) используется для трансформации массива. Он вызывает коллбек-функцию для каждого элемента исходного массива, а результат её работы записывает в новый массив, который и будет результатом выполнения метода.

// массив.map((element, index, array) => {
// Тело коллбек-функции
// });

// Поэлементно перебирает оригинальный массив.
// Не изменяет оригинальный массив.
// Результат работа коллбек-функции записывается в новый массив.
// Возвращает новый массив такой же длины.
// Его можно использовать для того, чтобы изменить каждый элемент массива. Оригинальный массив используется как эталон, на базе которого можно сделать другую коллекцию.

// const planets = ["Земля", "Марс", "Венера", "Юпитер"];

// const planetsInUpperCase = planets.map(planet => planet.toUpperCase());
// console.log(planetsInUpperCase); // ['ЗЕМЛЯ', 'МАРС', 'ВЕНЕРА', 'ЮПИТЕР']

// const planetsInLowerCase = planets.map(planet => planet.toLowerCase());
// console.log(planetsInLowerCase); // ['земля', 'марс', 'венера', 'юпитер']

// Оригинальный массив не изменился
// console.log(planets); // ['Земля', 'Марс', 'Венера', 'Юпитер']

// Использование анонимных стрелочных функций с неявным возвратом сильно сокращает «шум» объявления коллбек-функции, делая код чище и проще для восприятия.

// Массив объектов

// Мы уже знаем что повседневная задача это манипуляция массивом объектов. Например, получить массив значений свойства из всех объектов. Есть массив студентов, а нужно получить отдельный массив их имён.

// const students = [
//   { name: "Манго", score: 83 },
//   { name: "Поли", score: 59 },
//   { name: "Аякс", score: 37 },
//   { name: "Киви", score: 94 },
//   { name: "Хьюстон", score: 64 },
// ];

// const names = students.map(student => student.name);
// console.log(names); // ['Манго', 'Поли', 'Аякс', 'Киви', 'Хьюстон']

// Используя метод map() можно перебрать массив объектов, и в коллбек-функции вернуть значение свойства каждого из них.

//? -----------------------------------------------// 19 Метод flat--------------------------------------------------

// .flat(depth) - принимает глубину вложений (цифра) возвращает новый массив, где вложенные подмассивы записаны в один массив.

// Пример 1

// const arr = [1, 2, [3, 4, [5, 6, [7, 8]]]];
// const result = arr.flat(3); // (3) - в данном случае означает уровень вложенности, то есть сколько подмассивов есть в массиве
// console.log(result);

// Пример 2

// const arr = [1, 2, [3, 4, [5, 6, [7, 8, [[[[[[[9, [[[[[[[10]]]]]]]]]]]]]]]]]];
// const result = arr.flat(Infinity);
// console.log(result);
// ?-----------------------------------------------// 20 Метод flatMap------------------------------------------------

// Метод flatMap(callback) аналогичен методу map(), но применяется в случаях когда результат это многомерный массив который необходимо «разгладить».

// массив.flatMap((element, index, array) => {
// Тело коллбек-функции
// });

// В массиве students хранится список студентов со списком предметов которые посещает студент в свойстве courses. Несколько студентов могут посещать один и тот же предмет. Необходимо составить список всех предметов которые посещает эта группа студентов, пока даже повторяющихся.

// const students = [
//   { name: "Манго", courses: ["математика", "физика"] },
//   { name: "Поли", courses: ["информатика", "математика"] },
//   { name: "Киви", courses: ["физика", "биология"] },
// ];

// students.map(student => student.courses);
// [['математика', 'физика'], ['информатика', 'математика'], ['физика', 'биология']]

// students.flatMap(student => student.courses);
// ['математика', 'физика', 'информатика', 'математика', 'физика', 'биология'];

// Он вызывает коллбек-функцию для каждого элемента исходного массива, а результат её работы записывает в новый массив. Отличие от map() в том, что новый массив «разглаживается» на глубину равную единице (одна вложенность). Этот разглаженный массив и есть результат работы flatMap().

// ?----------------------------------------------// 21 Метод every()---------------------------------------------

// Проверяет проходят ли все элементы массива тест предоставляемый коллбек-функцией. Возвращает true или false.

// массив.every((element, index, array) => {
// Тело коллбек-функции
// });

// Не изменяет оригинальный массив.
// Поэлементно перебирает оригинальный массив.
// Возвращает true если все элементы массива удовлетворяют условию.
// Возвращает false если хотябы один элемент массив не удовлетворяет условию.
// Перебор массива прекращается если коллбек возвращает false.
// Все элементы больше либо равны нулю? - да
// console.log([1, 2, 3, 4, 5].every((value) => value >= 0)); // true

// Все элементы больше либо равны нулю? - нет
// console.log([1, 2, 3, -10, 4, 5].every((value) => value >= 0)); // false

// ?----------------------------------------------// 22 Метод some()--------------------------------------------

// Проверяет проходит ли хотя бы один элемент массива тест предоставляемый коллбек-функцией. Возвращает true или false.

// массив.some((element, index, array) => {
// Тело коллбек-функции
// });

// Не изменяет оригинальный массив.
// Поэлементно перебирает оригинальный массив.
// Возвращает true если хотя бы один элемент массива удовлетворяет условию.
// Возвращает false если ни один элемент массив не удовлетворяет условию.
// Перебор массива прекращается если коллбек возвращает true.
// Есть хотя бы один элемент бо/льше либо равный нулю? - да
// [1, 2, 3, 4, 5].some(value => value >= 0); // true

// Есть хотя бы один элемент больше либо равный нулю? - да
// [-7, -20, 3, -10, -14].some(value => value >= 0); // true

// Есть хотя бы один элемент меньше нуля? - нет
// [1, 2, 3, 4, 5].some(value => value < 0); // false

// Есть хотя бы один элемент меньше нуля? - да
// [1, 2, 3, -10, 4, 5].some(value => value < 0); // true

//---------Массив объектов
// При работе с массивом объектов проверяется значение какого-то их свойства Например, есть массив объектов фруктов, необходимо узнать все ли фрукты есть в наличии и есть ли в наличии хоть какие-то фрукты более 0 штук.

// const fruits = [
//   { name: "apples", amount: 100 },
//   { name: "bananas", amount: 0 },
//   { name: "grapes", amount: 50 },
// ];

// every вернет true только если всех фруктов будет больше чем 0 штук
// const allAvailable = fruits.every(fruit => fruit.amount > 0); // false

// some вернет true если хотябы одного фрукта будет больше чем 0 штук
// const anyAvailable = fruits.some(fruits => fruits.amount > 0); // true

// ?--------------------------------------------// 23 Метод reduce()----------------------------------------------------

// Метод reduce(callback, initialAcc) используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата, как аккумулятор. Немного сложнее других в усвоении, но результат стоит того.

// reduce ((acc, element, index, arr) => {}, inititalAcc) - возвращает всё, что вы напишете. Зависит от логики и начального значения аккумулятора. Аккумулятор - это внешняя переменная за пределами цикла, которая доступна для корректировки на каждой итерации. На каждой итерации аккумулятор становится тем, что вернулось на предыдущей итерации. Если не задать начальное значение inititalAcc, то аккумулятор станет первым элементом массива и пропустится первая итерация. Результат работы этого метода - это тот аккумулятор который функция вернула на последней итерации.

// массив.reduce((previousAcc, element, index, arr) => {
// Тело коллбек-функции
// }, initialAcc);// В данном случае в скобках - (переменная-накопитель или аккумулятор, элемент, индекс, массив)

// Не изменяет оригинальный массив.
// Поэлементно перебирает оригинальный массив.
// Возвращает что угодно.
// Делает что угодно.

// -------------------------------*Пример задачи без метода .reduce:

// const arr = [1, 2, 3, 4, 54, 6, 45];
// let sum = 0;
// for (const num of arr) {
//   sum += num;
// }
// console.log(sum);

// -------------------------------*Пример задачи с применением метода .reduce:

// const arr = [1, 2, 3, 4, 54, 6, 45];
// const sumAll = arr.reduce((sum, num) => sum + num, 0);
// console.log(sumAll);

// --------------Подробное объяснение решения задачи:

// 1. arr.reduce((sum=0, num = 1) => 0 + 1 = 1, 0);
// 1. arr.reduce((sum=1, num = 2) => 1 + 2 = 3, 0);
// 1. arr.reduce((sum=3, num = 3) => 3 + 3 = 6, 0);
// 1. arr.reduce((sum=6, num = 4) => 6 + 4 = 10, 0);
// 1. arr.reduce((sum=10, num = 54) => 10 + 54 = 64, 0);
// 1. arr.reduce((sum=64, num = 6) => 64 + 6 = 70, 0);
// 1. arr.reduce((sum=70, num = 45) => 70 + 45 = 115, 0);

// Результат последней итерации и будет выведена в консоль, то есть 115

// -----------------------------------------------------------------------------

// Легче всего представить его работу на примере подсчёта суммы элементов массива.

// const total = [2, 7, 3, 14, 6].reduce((previousAcc, number) => {
//   return previousAcc + number;
// }, 0);

// console.log(total); // 32

// Первый параметр коллбек-функции (previousAcc) это аккумулятор, то есть промежуточный результат. Значение которое вернёт коллбек-функция на текущей итерации, будет значением этого параметра на следующей.

// Вторым аргументом для reduce() можно передать необязательное начальное значение аккумулятора - параметр initialAcc.

// # Вначале метод reduce() создаёт внутреннюю переменную-аккумулятор и
// # присваивает ей значение параметра initialAcc или первого элемента
// # перебираемого массива, если initialAcc не задан.
// previousAcc = 0

// # Далее коллбек-функция вызывается для каждого элемента массива. Текущее значение
// # параметра previousValue это то, что вернула коллбек-функция на прошлой итерации.
// Итерация 1 -> previousValue = 0 -> number = 2 -> return 0 + 2 -> return 2
// Итерация 2 -> previousValue = 2 -> number = 7 -> return 2 + 7 -> return 9
// Итерация 3 -> previousValue = 9 -> number = 3 -> return 9 + 3 -> return 12
// Итерация 4 -> previousValue = 12 -> number = 14 -> return 12 + 14 -> return 26
// Итерация 5 -> previousValue = 26 -> number = 6 -> return 26 + 6 -> return 32

// # После того как весь массив перебран, метод reduce() возвращает значение аккумулятора.
// Результат - 32

// То есть метод reduce() используется когда необходимо взять «много» и привести к «одному».
// В повседневных задачах его применение сводится к работе с числами.

// ------------Массив объектов
// При работе с массивом объектов выполняется редуцирование по значению какого-то свойства. Например, есть массив студентов с баллами за тест. Необходимо получить средний бал.

// const students = [
//   { name: "Манго", score: 83 },
//   { name: "Поли", score: 59 },
//   { name: "Аякс", score: 37 },
//   { name: "Киви", score: 94 },
//   { name: "Хьюстон", score: 64 },
// ];

// Название аккумулятора может быть произвольным, это просто параметр функции
// const totalScore = students.reduce((total, student) => {
//   return total + student.score;
// }, 0);

// const averageScore = totalScore / students.length;

// ------------Продвинутый reduce
// Допустим у нас есть следующая задача: из массива постов твиттера отдельного пользователя необходимо посчитать сумму всех лайков. Можно перебрать циклом for или forEach, каждое из этих решений потребует дополнительного кода. А можно использовать reduce.
// const tweets = [
//     { id: "000", likes: 5, tags: ["js", "nodejs"] },
//     { id: "001", likes: 2, tags: ["html", "css"] },
//     { id: "002", likes: 17, tags: ["html", "js", "nodejs"] },
//     { id: "003", likes: 8, tags: ["css", "react"] },
//     { id: "004", likes: 0, tags: ["js", "nodejs", "react"] },
//   ];

// Пройдем по всем элементам коллекции и прибавим значения свойства likes
// к аккумулятору, начальное значение которого укажем 0.
//   const likes = tweets.reduce((totalLikes, tweet) => totalLikes + tweet.likes, 0);

//   console.log(likes); // 32

// Наверное подсчет лайков не одиночная операция, поэтому напишем функцию
// для подсчета лайков из коллекции
//   const countLikes = tweets => {
//     return tweets.reduce((totalLikes, tweet) => totalLikes + tweet.likes, 0);
//   };

//   console.log(countLikes(tweets)); // 32

//   Заметили свойство tags у каждого поста? Продолжая тему reduce, мы соберем в массив все теги, которые встречаются в постах.

//   const tweets = [
//     { id: "000", likes: 5, tags: ["js", "nodejs"] },
//     { id: "001", likes: 2, tags: ["html", "css"] },
//     { id: "002", likes: 17, tags: ["html", "js", "nodejs"] },
//     { id: "003", likes: 8, tags: ["css", "react"] },
//     { id: "004", likes: 0, tags: ["js", "nodejs", "react"] },
//   ];

// Пройдем по всем элементам коллекции и добавим значения свойства tags
// к аккумулятору, начальное значение которого укажем пустым массивом [].
// На каждой итерации пушим в аккумулятор все элементы tweet.tags и возвращаем его.
//   const tags = tweets.reduce((allTags, tweet) => {
//     allTags.push(...tweet.tags);

//     return allTags;
//   }, []);

//   console.log(tags);

// Наверное сбор тегов не одиночная операция, поэтому напишем функцию
// для сбора тегов из коллекции
//   const getTags = tweets =>
//     tweets.reduce((allTags, tweet) => {
//       allTags.push(...tweet.tags);

//       return allTags;
//     }, []);

//   console.log(getTags(tweets));

//   После того, как мы собрали все теги из постов, хорошо бы было посчитать количество уникальных тегов в массиве.
// И снова reduce тут как тут.

//   const tweets = [
//     { id: "000", likes: 5, tags: ["js", "nodejs"] },
//     { id: "001", likes: 2, tags: ["html", "css"] },
//     { id: "002", likes: 17, tags: ["html", "js", "nodejs"] },
//     { id: "003", likes: 8, tags: ["css", "react"] },
//     { id: "004", likes: 0, tags: ["js", "nodejs", "react"] },
//   ];

//   const getTags = tweets =>
//     tweets.reduce((allTags, tweet) => {
//       allTags.push(...tweet.tags);

//       return allTags;
//     }, []);

//   const tags = getTags(tweets);

// Вынесем callback-функцию отдельно, а в reducе передадим ссылку на нее.
// Это стандартная практика если callback-функция довольно большая.

// Если в объекте-аккумуляторе acc нету своего свойства с ключем tag,
// то создаем его и записывает ему значение 0.
// В противном случае увеличиваем значение на 1.
//   const getTagStats = (acc, tag) => {
//     if (!acc.hasOwnProperty(tag)) {
//       acc[tag] = 0;
//     }

//     acc[tag] += 1;

//     return acc;
//   };

// Начальное значение аккумулятора это пустой объект {}
//   const countTags = tags => tags.reduce(getTagStats, {});

//   const tagCount = countTags(tags);
//   console.log(tagCount);

// ?----------------------------------------------// 24 Метод sort()--------------------------------------------------------

// Метод sort() сортирует элементы массива, но в отличии от остальных перебирающих методов, он сортирует исходный массив.

// Сортирует и изменяет исходный массив.
// Возвращает изменённый массив, то есть ссылку на отсортированный исходный.
// По умолчанию сортирует по возрастанию.
// Сортировка происходит путём приведения значений к строке и сравнения порядковых номеров в таблице Unicode.
// Такой массив чисел будет отсортирован по возврастанию.

// const scores = [61, 19, 74, 35, 92, 56];
// scores.sort();
// console.log(scores); // [19, 35, 56, 61, 74, 92]

// Но, так как по умолчанию значения приводятся к строке, стандартная сортировка чисел работает необычно. Поэтому в следующем упражнении мы рассмотрим как задавать свой порядок сортировки.

// const scores = [27, 2, 41, 4, 7, 3, 75];
// scores.sort();
// console.log(scores); // [2, 27, 3, 4, 41, 7, 75]

// Массив строк сортируется по алфавиту.

// const students = ["Вика", "Андрей", "Олег", "Юля", "Борис", "Катя"];
// students.sort();
// console.log(students); // [ 'Андрей', 'Борис', 'Вика', 'Катя', 'Олег', 'Юля' ]

// При этом порядковый номер заглавных букв меньше чем у прописных.

// const letters = ["b", "B", "a", "A", "c", "C"];
// letters.sort();
// console.log(letters); // ['A', 'B', 'C', 'a', 'b', 'c']

// Из-за того, что сортируется исходный массив, нарушается принцип чистоты функций и нельзя удобно сделать несколько производных коллекций на базе исходной. Например, сделать коллекцию отсортированную по возрастанию, а другую по убыванию. Поэтому перед сортировкой делают полную копию исходного массива и сортируют уже её.

// const scores = [61, 19, 74, 35, 92, 56];
// const ascendingScores = [...scores].sort();

// console.log(scores); // [61, 19, 74, 35, 92, 56]
// console.log(ascendingScores); // [19, 35, 56, 61, 74, 92]

// Свой порядок сортировки чисел
// Для указания своего порядка сортировки методу sort(compareFunction) нужно передать коллбек-функцию с двумя параметрами. Это функция сравнения (compare function), порядок сортировки зависит от её результата. Метод sort() будет вызывать её для произвольных двух элементов.

// массив.sort((a, b) => {
// Тело коллбек-функции
// });

// a - первый элемент для сравнения.
// b - второй элемент для сравнения.
// Если вызов compareFunction(a, b) возвращает любое отрицательное значение, то есть a меньше b, сортировка поставит a перед b. Это сортировка по возрастанию.

// const scores = [61, 19, 74, 35, 92, 56];
// const ascendingScores = [...scores].sort((a, b) => a - b);
// console.log(ascendingScores); // [19, 35, 56, 61, 74, 92]

// Если вызов compareFunction(a, b) возвращает любое положительное значение больше нуля, то есть b больше a, сортировка поставит b перед a. Это сортировка по убыванию.

// const scores = [61, 19, 74, 35, 92, 56];
// const descendingScores = [...scores].sort((a, b) => b - a);
// console.log(descendingScores); // [92, 74, 61, 56, 35, 19]

// Eсли вызов compareFunction(a, b) вернёт 0, сортировка оставит a и b неизменными по отношению друг к другу, но отсортирует их по отношению ко всем другим элементам. Но вообще не важно, что возвращать, если их взаимный порядок не имеет значения.

// Свой порядок сортировки строк
// Для сортировки строк в алфавитном порядке, по возрастанию или убыванию, используется метод строк localeCompare().

// firstString.localeCompare(secondString)

// Он вызывается на строке которую нужно сравнить (firstString) с той, что передана ему как аргумент (secondString).

// "a".localeCompare("b"); // -1
// "b".localeCompare("a"); // 1
// "a".localeCompare("a"); // 0
// "b".localeCompare("b"); // 0

// Возвращает отрицательное значение если firstString должна быть перед secondString.
// Возвращает положительное значение больше нуля если firstString должна быть после secondString.
// Если строки одинаковы, возвращается ноль.
// Это удобно использовать при сортировке строк, так как метод sort() ожидает такие же значения от коллбек-функции.

// const students = ["Вика", "Андрей", "Олег", "Юля", "Борис", "Катя"];

// const inAlphabetOrder = [...students].sort((a, b) => a.localeCompare(b));
// console.log(inAlphabetOrder); // ['Андрей', 'Борис', 'Вика', 'Катя', 'Олег', 'Юля']

// const inReversedOrder = [...students].sort((a, b) => b.localeCompare(a));
// console.log(inReversedOrder); // ['Юля', 'Олег', 'Катя', 'Вика', 'Борис', 'Андрей']

// Сортировка объектов
// При работе с массивом объектов сортировка выполняется по числовому или строчному значению какого-то свойства. Например, есть группа студентов с баллами за тест. Необходимо отсортировать массив объектов по возрастанию и убыванию количества баллов, и по имени студента.

// const students = [
//   { name: "Манго", score: 83 },
//   { name: "Поли", score: 59 },
//   { name: "Аякс", score: 37 },
//   { name: "Киви", score: 94 },
// ];

// const inAscendingScoreOrder = students.sort(
//   (firstStudent, secondStudent) => firstStudent.score - secondStudent.score
// );

// const inDescendingScoreOrder = students.sort(
//   (firstStudent, secondStudent) => secondStudent.score - firstStudent.score
// );

// const inAlphabeticalOrder = students.sort((firstStudent, secondStudent) =>
//   firstStudent.name.localeCompare(secondStudent.name)
// );

//? ------------------------------------------------Метод toString------------------------------------------

// Метод toString соединяет массив и возвращает одну строку, содержащую каждый элемент массива, разделённый запятыми.

// const arr = ['Янв', 'Фев', 'Мар', 'Апр'];
// const string = arr.toString(); // присваивает 'Янв,Фев,Мар,Апр' переменной string.
// console.log(string);

//? ------------------------------------------------Цепочки методов---------------------------------------------

// Есть массив объектов с именами, баллами и посещаемыми предметами каждого студента.

// const students = [
//   { name: "Манго", score: 83, courses: ["математика", "физика"] },
//   { name: "Поли", score: 59, courses: ["информатика", "математика"] },
//   { name: "Аякс", score: 37, courses: ["физика", "биология"] },
//   { name: "Киви", score: 94, courses: ["литература", "информатика"] },
// ];

// Необходимо получить массив их имён отсортированный по возрастанию баллов за тест. Для этого мы отсортируем копию массива методом sort(), после чего методом map() составим массив значений свойства name из сортированного массива.

// const sortedByAscendingScore = [...students].sort((a, b) => a.score - b.score);
// const names = sortedByAscendingScore.map(student => student.name);

// console.log(names); // ['Аякс', 'Поли', 'Манго', 'Киви']

// Проблема в том, что у нас появляются промежуточные переменные после каждой операции кроме финальной. Переменная sortedByAscendingScore лишняя и необходима только для хранения промежуточного результата.

// Избавиться от таких «мёртвых» переменных можно группируя вызовы методов в цепочки. Каждый следующий метод будет выполняться на результате работы предыдущего.

// const names = [...students]
//   .sort((a, b) => a.score - b.score)
//   .map(student => student.name);

// console.log(names); // ['Аякс', 'Поли', 'Манго', 'Киви']

// Делаем копию исходного массива перед сортировкой.
// На копии вызываем метод sort().
// К результату работы метода sort() применяем метод map().
// Переменной names присваивается результат работы метода map().
// Получим сортированный по алфавиту массив уникальных посещаемых предметов.

// const uniqueSortedCourses = students
//   .flatMap(student => student.courses)
//   .filter((course, index, array) => array.indexOf(course) === index)
//   .sort((a, b) => a.localeCompare(b));

// console.log(uniqueSortedCourses); // ['биология', 'информатика', 'литература', 'математика', 'физика']

// На исходном массиве вызываем flatMap() и делаем разглаженный массив всех курсов.
// К результату метода flatMap() применяем метод filter() для фильтрации уникальных элементов.
// На результате метода filter() вызываем sort().
// Переменной uniqueSortedCourses присваивается результат работы метода sort().
// Цепочка методов может быть произвольной длины, но обычно не более 2-3 операций. Во-первых, перебирающие методы используются для сравнительно простых операций над коллекцией. Во-вторых, вызов каждого последующего метода, это дополнительный перебор массива, что при достаточном количестве, может сказаться на производительности.

//? ----------------------------------------Константы с массивами или объектами------------------------------------------------

// Константы, содержащие массивы и объекты, работают интересным образом. JavaScript не разрешает изменять значения этих констант, но изменять свойства объектов и значения элементов массивов - можно.

// Константы, содержащие массивы и объекты, работают интересным образом. JavaScript не разрешает изменять значения этих констант, но изменять свойства объектов и значения элементов массивов - можно.

// Давайте посмотрим на примерах. Пусть у нас дан вот такой объект:

// const obj = {a: 1, b: 2, c: 3};
// Давайте попробуем записать в него что-то другое:

// obj = 123; // ошибка
// Давайте попробуем записать в константу другой объект:

// obj = {x: 1, y: 2, z: 3}; // ошибка
// Однако, если мы попробуем изменить свойство объекта, то это сработает:

// obj.a = '+'; // работает!

// То есть, если нужно изменить значения в массиве или объекте - нужно это делать, обращаясь отдельно к каждому элементу

// Пример

// Исходные данные:
// const arr = ['a', 'b', 'c'];

// Решение № 1:
// arr = [1, 2, 3];
// console.log(arr)// Это решение выдаст ошибку

// Решение № 2:
// arr[0] = 4;
// arr[1] = 5;
// arr[2] = 6;
// console.log(arr); // Это решение выдаст массив [4, 5, 6];

// !==============================================Деструктуризация массивов========================================

// Деструктуризирующее присваивание можно использовать и для массивов, но с некоторыми особенностями.

// Вместо фигурных скобок {} используются квадратные [].
// Переменным, указанным в квадратных скобках [], будут последовательно присваиваться значения элементов массива.
// Например, есть массив цветов из которого нужно в отдельные переменные получить значения каждой составляющей цвета.

// const rgb = [200, 255, 100];
// const [red, green, blue] = rgb;
// console.log(`R:${red},G:${green},B:${blue}`); // "R:200,G:255,B:100"

// После ключевого слова const или let ставим открывающую и закрывающую квадратные скобки, как при объявлении массива. Внутри скобок, через запятую, указываем имена переменных, в которые будут помещены значения массива.

// В результате такой записи будут созданы 3 переменные и в них будут помещены элементы в нумерованном порядке - от 0 и до конца массива.

// При деструктуризации массивов, значение переменной может быть присвоено после ее объявления. На практике это используется редко.

// const rgb = [200, 255, 100];
// let red, green, blue;

// [red, green, blue] = rgb;

// console.log(`R:${red},G:${green},B:${blue}`); // "R:200,G:255,B:100"

// Если переменных больше чем элементов массива, им будет присвоено undefined, поэтому можно указывать значения по умолчанию.

// const rgb = [200, 100, 255];

// const [red, green, blue, alfa = 0.3] = rgb;

// console.log(`R:${red},G:${green},B:${blue},Alfa:${alfa}`); // "R:200,G:100,B:255,Alfa:0.3"

// Иногда из массива необходимо деструктуризировать только первые N элементов, а остальные сохранить в одну переменную в виде массива. При деструкции массива можно распаковать и присвоить оставшуюся часть элементов массива переменной,
// используя операцию ... (rest).

// const rgb = [200, 255, 100];

// const [red, ...colors] = rgb;

// console.log(red); // "200"
// console.log(colors); // [255, 100]

// Элементы можно пропускать. Допустим, из массива rgb необходимо взять только последнее значение. На практике эта возможность используется редко.

// const rgb = [200, 100, 255];

// const [, , blue] = rgb;

// console.log(`Blue: ${blue}`); // "Blue: 255"
// -----------------------------------------------------------------
// function func() {
//   return [2025, 12, 31];
// }
// Деструктуризируем возвращаемое этой функцией значение:

// let [year, month, day] = func();
// console.log(func);
// ------------------------------------------------------------------
// function func() {
//   return ['John', 'Smit', 'development', 'programmer', 2000];
// }
// let [name, surname, department, position, salary] = func();
// console.log(func);
// ----------------------------------------------------------------------
// function func() {
//   return ['John', 'Smit', 'development', 'programmer', 2000];
// }
// let arr = func();

// let name = arr[0];
// let surname = arr[1];
// let department = arr[2];
// let position = arr[3];
// let salary = arr[4];
// console.log(func);
// ------------------------------------------------------------------------
