// !======================================================ОБЪЕКТЫ========================================================

// Объекты позволяют описать и сгруппировать характеристики некоторой сущности - пользователя, книги, продукта в магазине, чего угодно. Объекты ещё называют словарями, то есть они содержат термины (свойства) и их определения (значения).

// Объекты (в том числе и массивы, как вы уже знаете) считаются сложными типами данных. Строки, числа, логические значения считаются простыми, или примитивными типами данных. Их часто так и называют - примитивы, подразумевая все то, что не является объектом.

// В JavaScript семь примитивных типов данных: string, number, boolean, null, undefined, symbol, bigint. Запомните их количество и названия - это часто спрашивают на собеседованиях.

// ?---------------------------------------------------Создание объекта------------------------------------------------

// Для объявления используются фигурные скобки {} - литерал объекта.

// В примере ниже:
// title - ключ или свойство объекта
// "The Last Kingdom" - значение ключа или значение свойства
// Ключи в объектах обычно являются строками или символами и не имеют упорядоченной структуры (в отличие от массивов).
// title: "The Last Kingdom" - это пара ключ-значение
// Значением может быть что угодно: число, строка, булевый тип, массив, объект вложенный в основной объект и т. п.

// Массивы обычно используются для хранения коллекции элементов одного типа (например, чисел или строк), в то время как объекты используются для хранения данных с различными типами и доступом по имени ключа.

// const book = {
//   title: "The Last Kingdom",
//   author: "Bernard Cornwell",
//   genres: ["historical prose", "adventure"],
//   isPublic: true,
//   rating: 8.38,
// };

// При создании объекту можно добавить свойства, каждое из которых описывается парами ключ:значение. Ключ ещё называют именем свойства и это всегда строка. Значением свойства могут быть любые типы: примитивы, массивы, объекты, були, функции и т. п. Свойства разделяются запятой.

// Правила именования ключей просты:

// Если ключ заключен в кавычки, то это может быть произвольная строка.
// Если кавычек нет, то вступают ограничения - имя без пробелов, начинается на букву или символы _ и $.

// ?--------------------------------------------Вывод объекта в консоль------------------------------------------------

// const user = {
//     name: 'Sergii',
//     surname: 'Velychko',
//   };

//   Вариант 1
//   console.log(user['name'] + ' ' + user['surname']);

//   Вариант 2
//   const ns = `${user.name} ${user.surname}`;
//   console.log(ns);

//? ------------------------------------------Вложенные свойства-------------------------------------------

// const user = {
//     name: "Jacques Gluke",
//     tag: "jgluke",
//     location: {
//       country: "Jamaica",
//       city: "Ocho Rios",
//     },
//     stats: {
//       followers: 5603,
//       views: 4827,
//       likes: 1308,
//     },
//   };

//?--------------------------------------Обращение к свойствам через точку---------------------------

// Первый способ получить доступ к свойству объекта это синтаксис обьект.имя_свойства. Синтаксис «через точку» используется в большинстве случаев и подходит тогда, когда мы заранее знаем имя (ключ) свойства к которому хотим получить доступ.
// При этом важно помнить, что если ключ начинается с цифры - в объекте он всё равно является строкой. Но при этом к нему нужно обращаться через [], а не через точку.
// На место обращения будет возвращено значение свойства с таким именем.
// Если в объекте нет свойства с таким именем, на место обращения вернётся undefined.

// const book = {
//   title: 'The Last Kingdom',
//   author: 'Bernard Cornwell',
//   genres: ['historical prose', 'adventure'],
//   isPublic: true,
//   rating: 8.38,
//   1: 27,
// };

// const bookTitle = book.title;
// console.log(bookTitle); // Вернётся 'The Last Kingdom'
// console.log(book[1]);// Обращение к ключю, который является числом. Вернётся - 27

// const bookGenres = book.genres;
// console.log(bookGenres); // ['historical prose', 'adventurs']

// const bookPrice = book.price;
// console.log(bookPrice); // undefined

// ?---------------------------------------------Обращение к вложенным свойствам---------------------------

// Для доступа к вложенным свойствам используется цепочка обращейний «через точку». Например, если необходимо получить значение страны пользователя, записываем user.location.country, где user.location это обращение (путь) к объекту в свойстве location, а user.locaton.country обращение к свойству country в этом объекте. То есть «точка» указывает следующую вложенность.

// const user = {
//   name: "Jacques Gluke",
//   tag: "jgluke",
//   location: {
//     country: "Jamaica",
//     city: "Ocho Rios",
//   },
//   hobbies: ["swiming", "music", "sci-fi"],
// };

// const location = user.location;
// console.log(location); // Объект location

// const country = user.location.country;
// console.log(country); // 'Jamaica'

// Если значение свойства это массив, то в нашем примере user.hobbies обращение к этому массиву.Далее можно получить доступ к его элементам через квадратные скобки и индекс или использовать свойства и методы.

// const hobbies = user.hobbies;
// console.log(hobbies); // ['swiming', 'music', 'sci-fi']

// const firstHobby = user.hobbies[0];
// console.log(firstHobby); // 'swiming'

// const numberOfHobbies = user.hobbies

// ?-----------------------------------------Обращение к свойствам через квадратные скобки----------------------

// Второй способ получить доступ к свойству объекта это синтаксис обьект["имя свойства"]. Похоже на обращение к элементу массива с отличием в том, что в скобках указывается не индекс элемента, а имя свойства как строка.

// Синтаксис «квадратных скобок» используется значительно реже, в случае когда имя свойства заранее неизвестно или хранится в переменной, например как значение параметра функции.

// На место обращения будет возвращено значение свойства с таким именем.
// Если в объекте нет свойства с таким именем, на место обращения вернётся undefined.
// const book = {
//   title: "The Last Kingdom",
//   author: "Bernard Cornwell",
//   genres: ["historical prose", "adventure"],
//   isPublic: true,
//   rating: 8.38,
// };

// const bookTitle = book["title"];
// console.log(bookTitle); // 'The Last Kingdom'

// const bookGenres = book["genres"];
// console.log(bookGenres); // ['historical prose', 'adventurs']

// const propKey = "author";
// const bookAuthor = book[propKey];
// console.log(bookAuthor); // 'Bernard Cornwell'

// ?--------------------------------------Изменение значения свойства---------------------------------------

// После того как объект создан, значение его свойств можно изменить. Для этого необходимо обратиться к ним по имени, например «через точку», и присвоить новое значение.

// const book = {
//   title: "The Last Kingdom",
//   author: "Bernard Cornwell",
//   genres: ["historical prose", "adventure"],
//   isPublic: true,
//   rating: 8.38,
// };

// book.rating = 9;
// book.isPublic = false;
// book.genres.push("драма");

// console.log(book.rating); // 9
// console.log(book.isPublic); // false
// console.log(book.genres); // ['historical prose', 'adventures', 'драма']

// ?------------------------------------------------Добавление свойств----------------------------------------

// Операция добавления нового свойства после создания объекта ничем не отличается от изменения значения уже существующего свойства. Если при записи значения по имени, такого свойства в объекте нет, оно будет создано.

// const book = {
//   title: "The Last Kingdom",
//   author: "Bernard Cornwell",
//   genres: ["historical prose", "adventure"],
//   isPublic: true,
//   rating: 8.38,
// };

// book.pageCount = 836;
// book.originalLanguage = "en";
// book.translations = ["ua", "ru"];

// console.log(book.pageCount); // 836
// console.log(book.originalLanguage); // 'en'
// console.log(book.translations); // ['ua', 'ru']

// ?----------------------------------------------------Короткие свойства----------------------------------------------

// Иногда при создании объекта значение свойства необходимо взять из переменной или параметра функции с таким же именем как и само свойство.

// Синтксис в следующем примере слишком громоздкий, потому что приходится дублировать имя свойства и имя переменной в которой хранится необходимое значение.

// const name = "Генри Сибола";
// const age = 25;

// const user = {
//   name: name,
//   age: age,
// };

// console.log(user.name); // "Генри Сибола"
// console.log(user.age); // 25

// Синтаксис коротких свойств (shorthand properties) решает эту проблему, позволяя использовать имя переменной как имя свойства, а её значение как значение свойства.

// const name = "Генри Сибола";
// const age = 25;

// const user = {
//   name,
//   age,
// };

// console.log(user.name); // "Генри Сибола"
// console.log(user.age); // 25

// То есть при объявлении объекта достаточно указать только имя свойства, а значение будет взято из переменной с аналогичным именем.

// ?--------------------------------------------------Вычисляемые свойства----------------------------------------------

// Бывают ситуации когда при объявлении обьекта необходимо добавить свойство с именем которое мы заранее не знаем, потому что оно хранится как значение переменной или как результат выполнения функции.

// Раньше для этого необходимо было сначала создать объект, а потом добавлять свойства через квадратные скобки, что не совсем удобно.

// const propName = "name";
// const user = {
//   age: 25,
// };

// user[propName] = "Генри Сибола";
// console.log(user.name); // 'Генри Сибола'

// Синтаксис вычисляемых свойств (computed properties) помогает избежать лишнего кода и в некоторых случаях упростить его. Значением вычисляемого свойства может быть любое валидное выражение.

// const propName = "name";
// const user = {
//   age: 25,
// Имя этого свойства будет взято из значения переменной propName
//   [propName]: "Генри Сибола",
// };

// console.log(user.name); // 'Генри Сибола'

// ?---------------------------------------------------Оператор in--------------------------------------------------------------

// С помощью оператора in можно проверять наличие свойства в объекте. Давайте посмотрим на примере. Пусть у нас дан вот такой объект:

// let obj = {a: 1, b: 2, c: 3};
// Давайте проверим наличие в нашем объекте какого-нибудь свойства:

// console.log('b' in obj); // выведет true
// А теперь выполним проверку для несуществующего свойства:

// console.log('x' in obj); // выведет false

// ?-----------------------------------------------------Оператор delete-------------------------------------------------------

// Можно удалять элементы объектов с помощью оператора delete. Давайте посмотрим на примерах. Пусть у нас дан вот такой объект:

// let obj = {a: 1, b: 2, c: 3};
// Давайте удалим один из элементов нашего объекта:

// delete obj.b;
// Посмотрим, что у нас получилось:

// console.log(obj); // выведет {a: 1, c: 3}

// ?---------------------------------------------------Функция Array.isArray():---------------------------------------------

// Как было указано выше, оператор typeof не позволяет различать массивы и объекты. Иногда, однако, это необходимо сделать.
// На помощь придет функция Array.isArray():

// console.log( Array.isArray([]) ); // выведет true
// console.log( Array.isArray({}) ); // выведет fals

// ?-----------------------------------------------------Методы объекта-------------------------------------------------------

// Объекты могут хранить не только данные, но и функции для работы с этими данными - методы. Если значение свойства это функция, такое свойство называется методом объекта.

// ✅ Логически и синтаксически сгруппированные сущности
// const bookShelf = {
//     books: ["The Last Kingdom", "Dream Guardian"],
// Это метод объекта
//     getBooks() {
//       console.log("Этот метод будет возвращать все книги - свойство books");
//     },
// Это метод объекта
//     addBook(bookName) {
//       console.log("Этот метод будет добавлять новую книгу в свойство books");
//     },
//   };

// Вызовы методов
//   bookShelf.getBooks();
//   bookShelf.addBook("Новая книга");

// ?----------------------------------------Доступ к свойствам объекта в методах-------------------------------------

// Методы используются для работы со свойствами объекта, их изменения. Для доступа к объекту в методе используется не имя переменной, например bookShelf, а ключевое слово this - контекст. Значением this будет объект перед «точкой», то есть объект который вызвал этот метод, в нашем случае это ссылка на объект bookShelf.

// const bookShelf = {
//     books: ["The Last Kingdom"],
//     getBooks() {
//       console.log(this);
//     },
//   };

// Перед точкой стоит объект bookShelf,
// поэтому при вызове метода, this будет хранить ссылку на него.
//   bookShelf.getBooks(); // {books: ['The Last Kingdom'], getBooks: f}

// Для того чтобы получить доступ к свойствам объекта в методах, мы обращаемся к нему через this и дальше как обычно - «через точку» к свойствам.

// const bookShelf = {
//   books: ["The Last Kingdom"],
//   getBooks() {
//     return this.books;
//   },
//   addBook(bookName) {
//     this.books.push(bookName);
//   },
//   removeBook(bookName) {
//     const bookIndex = this.books.indexOf(bookName);
//     this.books.splice(bookIndex, 1);
//   },
// };

// console.log(bookShelf.getBooks()); // ["The Last Kingdom"]
// bookShelf.addBook("The Mist");
// bookShelf.addBook("Dream Guardian");
// console.log(bookShelf.getBooks()); // ['The Last Kingdom', 'The Mist', 'Dream Guardian']
// bookShelf.removeBook("The Mist");
// console.log(bookShelf.getBooks()); // ['The Last Kingdom', 'Dream Guardian']

//! ==================================================ПЕРЕБОР ОБЪЕКТА=======================================================

// В отличии от массива или строки, объект это не итерируемая сущность, то есть его нельзя перебрать циклами for или for...of.

// ?----------------------------------------------------Цикл for...in--------------------------------------------------------

// for (key in object) {
// инструкции
//   }

//   Переменная key доступная только в теле цикла. На каждой итерации в неё будет записано значение ключа (имя) свойства. Для того чтобы получить значение свойства с таким ключом (именем), используется синтаксис квадратных скобок.

//   const book = {
//     title: "The Last Kingdom",
//     author: "Bernard Cornwell",
//     genres: ["historical prose", "adventure"],
//     rating: 8.38,
//   };

//   for (const key in book) {
// Ключ
//     console.log(key);
// Значение свойства с таким ключом
//     console.log(book[key]);
//   }

// Пример (вариант 1):

// const user = {
//   name: 'Alice',
//   skills: {
//     html: false,
//     css: true,
//     react: false,
//   },
// };
// for (const key in user) {
//   console.log(user[key]);
// }

// Пример (вариант 2):

// const user = {
//   name: 'Alice',
//   skills: {
//     html: false,
//     css: true,
//     react: false,
//   },
// };
// for (const key in user) {
//   console.log(`${key}:${user[key]}`);
// }

// !==================================================Методы объекта================================================

// ?--------------------------------------------Метод ключевого слова this----------------------------------------------------

// const user = {
//   name: 'Alice',
//   skills: {
//     html: false,
//     css: true,
//     react: false,
//   },
//   sayHello(city) {
//     console.log(city);
//     console.log(this);
//     console.log(`Hello my name ${this.name}`);
//   },
// };
// user.sayHello('Kyiv');

// 1. Во время описания функции мы не знаем, на что ссылается this, мы узнаем это только тогда когда будет вызвана функция.
// 2. This ссылается на тот объект, который вызвал функцию (в данном случае - это объект user)

// ?--------------------------------------------Метод Object.hasOwnProperty()---------------------------------------------

// Разберём концепцию собственных и несобственных свойств объекта и научимся правильно использовать цикл for...in.

// const animal = {
//     legs: 4,
//   };
//   const dog = Object.create(animal);
//   dog.name = "Манго";
//   console.log(dog); // {name: 'Манго'}
//   console.log(dog.name); // 'Манго'
//   console.log(dog.legs); // 4

// Метод Object.create(animal) создаёт и возвращает новый объект, связывая его с объектом animal. Поэтому можно получить значение свойства legs обратившись к нему как dog.legs, хотя его нет в объекте dog - это несобственное свойство из объекта animal.

// Оператор in, который используется в цикле for...in, не делает различия между собственными и несобственными свойствами объекта. Эта особенность мешает, так как мы всегда хотим перебрать только собственные свойства. Для того чтобы узнать есть в объекте собственное свойство или нет, используется метод hasOwnProperty(key), который возвращает true или false.

// ❌ Возвращает true для всех свойств
// console.log("name" in dog); // true
// console.log("legs" in dog); // true

// ✅ Возвращает true только для собственных свойств
// console.log(dog.hasOwnProperty("name")); // true
// console.log(dog.hasOwnProperty("legs")); // false

// Поэтому при переборе циклом for...in необходимо на каждой итерации добавить проверку на собственное свойство. Даже если сейчас мы уверены в том что у объекта нет несобственных свойств, это оградит от возможных ошибок в будущем.

// const book = {
//     title: "The Last Kingdom",
//     author: "Bernard Cornwell",
//     genres: ["historical prose", "adventure"],
//     rating: 8.38,
//   };

//   for (const key in book) {
// Если это собственное свойство - выполняем тело if
//     if (book.hasOwnProperty(key)) {
//       console.log(key);
//       console.log(book[key]);
//     }

// Если это не собственное свойство - ничего не делаем
//   }

// ?-------------------------------------------Метод Object.keys()/Список ключей-------------------------------------------

// У встроенного класса Object есть несколько полезных методов для работы с объектами. Первый из них это Object.keys(obj), который принимает объект и возвращает массив ключей его собственных свойств. Если в объекте нет свойств, метод вернёт пустой массив.

// const book = {
//   title: 'The Last Kingdom',
//   author: 'Bernard Cornwell',
//   genres: ['historical prose', 'adventure'],
//   rating: 8.38,
// };
// const keys = Object.keys(book);
// console.log(keys); // ['title', 'author', 'genres', 'rating']
// console.log(keys.length); // Количество ключей в данном объекте

// Скомбинировав результат Object.keys() и цикл for...of можно удобно перебрать собственные свойства объекта, не прибегая к использованию архаического цикла for...in с проверками принадлежности свойств.

// const book = {
//     title: "The Last Kingdom",
//     author: "Bernard Cornwell",
//     genres: ["historical prose", "adventure"],
//     rating: 8.38,
//   };
//   const keys = Object.keys(book);

//   for (const key of keys) {
// Ключ
//     console.log(key);
// Значение свойства
//     console.log(book[key]);
//   }

//   Мы перебираем массив ключей объекта и на каждой итерации получаем значение свойства с таким ключом.

// ?--------------------------------------Метод Object.values()/Список значений-------------------------------------------------------

// Если метод Object.keys(obj) возвращает массив ключей собственных свойств обьекта, то метод Object.values(obj) возвращает массив значений его собственных свойств. Если в объекте нет свойств, метод Object.values(obj) вернёт пустой массив.

// const book = {
//   title: 'The Last Kingdom',
//   author: 'Bernard Cornwell',
//   rating: 8.38,
// };

// const values = Object.values(book);
// console.log(values); // ['The Last Kingdom', 'Bernard Cornwell', 8.38]
// console.log(values.length); //Количество значений в данном объекте

// Массив значений свойств также можно перебрать циклом for...of, например для получения общей суммы числовых значений.

// Допустим перед нами стоит задача посчитать общее количество продуктов в объекте формата имя-продукта: количество. Тогда подойдет метод Object.values() для того, чтобы получить массив всех значений и потом удобно их сложить

// const goods = {
//     apples: 6,
//     grapes: 3,
//     bread: 4,
//     cheese: 7,
//   };

//   const values = Object.values(goods); // [6, 3, 4, 7]

//   let total = 0;

//   for (const value of values) {
//     total += value;
//   }

//   console.log(total); // 20

//? -----------------------------------------------Метод Object.entries()----------------------------------------------------

// Метод Object.entries(obj) возвращает массив записей, каждым элементом которого будет еще один массив из 2-х элементов: имени свойства и значения этого свойства из объекта obj.

// const book = {
//     title: "The Last Kingdom",
//     author: "Bernard Cornwell",
//     rating: 8.38,
//   };
//   const keys = Object.keys(book);
//   console.log(keys); // ['title', 'author', 'rating']

//   const values = Object.values(book);
//   console.log(values); // ['The Last Kingdom', 'Bernard Cornwell', 8.38]

//   const entries = Object.entries(book);
//   console.log(entries);
// [["title", "The Last Kingdom"], ["author", "Bernard Cornwell"], ["rating", 8.38]]

// На практике метод Object.entries(obj) используется редко, только для каких-то очень специфичных задач. В 99% случаев будет использован метод Object.keys() или Object.values().

// ?---------------------------------------------------Метод Object.freeze()------------------------------------------

// Object.freeze() - это метод в JavaScript, который используется для замораживания объекта. Замораживание объекта делает его неизменным, что означает, что вы больше не можете добавлять, удалять или изменять его свойства или значения существующих свойств. Это полезно, когда вы хотите защитить объект от изменений.

// Пример использования Object.freeze():

// const myObject = {
//     name: 'John',
//     age: 30
//   };

// Замораживаем объект
//   Object.freeze(myObject);

// Попытка изменить свойство объекта
//   myObject.age = 31; // Это изменение будет проигнорировано, объект останется неизменным

// Попытка добавить новое свойство
//   myObject.city = 'New York'; // Это действие не приведет к добавлению свойства

// Попытка удалить свойство
//   delete myObject.name; // Это действие не удалит свойство

//   console.log(myObject); // Вывод: { name: 'John', age: 30 }
//   Обратите внимание, что Object.freeze() замораживает только поверхностные свойства объекта. Если объект содержит вложенные объекты, то они не замораживаются автоматически. Для замораживания вложенных объектов необходимо применить Object.freeze() к каждому из них отдельно.

//   Замороженные объекты полезны в ситуациях, когда вам необходимо гарантировать, что данные не будут изменены ненароком или намеренно после создания объекта.

// !===================================================МАССИВ ОБЪЕКТОВ======================================================

// В стандартный набор повседневных задач разработчика входит манипуляция массивом однотипных объектов. Это значит что все объекты в массиве гарантированно будут иметь одинаковый набор свойств, но с разными значениями.

// const books = [
//     {
//       title: "The Last Kingdom",
//       author: "Bernard Cornwell",
//       rating: 8.38,
//     },
//     {
//       title: "На берегу спокойных вод",
//       author: "Роберт Шекли",
//       rating: 8.51,
//     },
//     {
//       title: "Сон смешного человека",
//       author: "Федор Достоевский",
//       rating: 7.75,
//     },
//   ];

//   Для перебора такого массива используется стандартный цикл for...of. Значения свойств каждого объекта можно получить используя синтаксис «через точку», так как в каждом объекте набор свойств и их имена будут одинаковые, отличаются только значения.

//   for (const book of books) {
// Объект книги
//     console.log(book);
// Название
//     console.log(book.title);
// Автор
//     console.log(book.author);
// Рейтинг
//     console.log(book.rating);
//   }

//   Например, получим список названий всех книг в коллекции books.

//   const bookNames = [];

//   for (const book of books) {
//     bookNames.push(book.title);
//   }

//   console.log(bookNames); // ["The Last Kingdom", "На берегу спокойных вод", "Сон смешного человека"]

//   Узнаем средний рейтинг всей нашей коллекции. Для этого сложим все рейтинги, после чего разделим это значение на количество книг в коллекции.

//   let totalRating = 0;

//   for (const book of books) {
//     totalRating += book.rating;
//   }

//   const averageRating = (totalRating / books.length).toFixed(1);
//   console.log(averageRating); // 8.2

// !==================================================Практика=====================================================

// Задача № 1

// Условие задачи:

// Создать функцию, которая будет принимать 3 параметра и формировать объект покупки:
// 1. Название продукта
// 2. Количество единиц
// 3. Цена за 1 единицу товара
// 4. Функция должна возвращать сформированный объект с ключами name, price, guantity, totalPrice

// Решение задачи (вариант 1):

// function createBasket(name, quantity, price) {
//   const totalPrice = price * quantity;
//   const productObj = {
//     name,
//     quantity,
//     price,
//     totalPrice,
//   };
//   return productObj;
// }
// console.log(createBasket('pizza', 3, 120));
// console.log(createBasket('apple', 13, 1200));

// Решение задачи (вариант 2):

// function createBasket(name, quantity, price) {
//   const totalPrice = price * quantity;
//   return {
//     name,
//     quantity,
//     price,
//     totalPrice,
//   };
// }
// console.log(createBasket('pizza', 3, 120));
// console.log(createBasket('apple', 13, 1200));

// ?----------------------------------------Константы с массивами или объектами------------------------------------------------

// Константы, содержащие массивы и объекты, работают интересным образом. JavaScript не разрешает изменять значения этих констант, но изменять свойства объектов и значения элементов массивов - можно.

// Константы, содержащие массивы и объекты, работают интересным образом. JavaScript не разрешает изменять значения этих констант, но изменять свойства объектов и значения элементов массивов - можно.

// Давайте посмотрим на примерах. Пусть у нас дан вот такой объект:

// const obj = {a: 1, b: 2, c: 3};
// Давайте попробуем записать в него что-то другое:

// obj = 123; // ошибка
// Давайте попробуем записать в константу другой объект:

// obj = {x: 1, y: 2, z: 3}; // ошибка
// Однако, если мы попробуем изменить свойство объекта, то это сработает:

// obj.a = '+'; // работает!

// То есть, если нужно изменить значения в массиве или объекте - нужно это делать, обращаясь отдельно к каждому элементу

// Пример

// Исходные данные:
// const obj = { a: 1, b: 2, c: 3 };

// Решение № 1:
// obj = { a: 4, b: 5, c: 6 };
// console.log(obj); // Это решение выдаст ошибку

// Решение № 2:

// obj.a = '2';
// obj.b = '3';
// obj.c = '4';
// console.log(obj); // Это решение выдаст объект [4, 5, 6];

// !=============================================Деструктуризация объектов=============================================

// Сложные данные всегда представлены объектом. Множественные обращения к свойствам объекта визуально загрязняют код.
// Деструктуризация позволяет «распаковать» значения свойств объекта в локальные переменные. Это делает код в месте их использования менее «шумным».

// const book = {
//     title: "The Last Kingdom",
//     author: "Bernard Cornwell",
//     genres: ["historical prose", "adventure"],
//     isPublic: true,
//     rating: 8.38,
//   };

// Деструктуризируем
//   const { title, author, isPublic, rating, coverImage } = book;
//   console.log(coverImage); // undefined

//   const accessType = isPublic ? "публичном" : "закрытом";
//   const message = `Книга ${title} автора ${author} с рейтингом ${rating} находится в ${accessType} доступе.`

// Деструктуризация всегда находится в левой части операции присвоения. Переменным внутри фигурных скобок присваиваются значения свойств объекта. Если имя переменной и имя свойства совпадают, то происходит присваивание, в противном случае ей будет присвоено undefined. Порядок объявления переменных в фигурных скобках не важен.

// ?-----------------------------------------------Значения по умолчанию------------------------------------------

// Для того чтобы избежать присвоения undefined при деструктуризации несуществующих свойств объекта, можно задать переменным значения по умолчанию, которые будут присвоены только в случае когда в объекте нет свойства с таким именем.

// const book = {
//     title: "The Last Kingdom",
//     author: "Bernard Cornwell",
//   };

// Добавим картинку обложки если её нет в объекте книги
//   const {
//     title,
//     coverImage = "https://via.placeholder.com/640/480",
//     author,
//   } = book;

//   console.log(title); // The Last Kingdom
//   console.log(author); // Bernard Cornwell
//   console.log(coverImage); // https://via.placeholder.com/640/480

// ?----------------------------------------------Изменение имени переменной--------------------------------------

// При деструктуризации можно изменить имя переменной в которую распаковывается значение свойства. Сначала пишем имя свойства из которого хотим получить значение, после чего ставим двоеточие и пишем имя переменной в которую необходимо поместить значение этого свойства.

// const firstBook = {
//     title: "The Last Kingdom",
//     coverImage:
//       "https://images-na.ssl-images-amazon.com/images/I/51b5YG6Y1rL.jpg",
//   };

//   const {
//     title: firstTitle,
//     coverImage: firstCoverImage = "https://via.placeholder.com/640/480",
//   } = firstBook;

//   console.log(firstTitle); // The Last Kingdom
//   console.log(firstCoverImage); // https://images-na.ssl-images-amazon.com/images/I/51b5YG6Y1rL.jpg

//   const secondBook = {
//     title: "Сон смешного человека",
//   };

//   const {
//     title: secondTitle,
//     coverImage: secondCoverImage = "https://via.placeholder.com/640/480",
//   } = secondBook;

//   console.log(secondTitle); // Сон смешного человека
//   console.log(secondCoverImage); // https://via.placeholder.com/640/480

// Такая запись читается как «Создать переменную firstTitle, в которую поместить значение свойства title из объекта firstBook»    и т. д.

// ?-----------------------------------------------Деструктуризация в циклах----------------------------------------

// При переборе массива объектов циклом for...of получаеются множественные обращения к свойствам объекта.

// const books = [
//   {
//     title: "The Last Kingdom",
//     author: "Bernard Cornwell",
//     rating: 8.38,
//   },
//   {
//     title: "На берегу спокойных вод",
//     author: "Роберт Шекли",
//     rating: 8.51,
//   },
// ];

// for (const book of books) {
//   console.log(book.title);
//   console.log(book.author);
//   console.log(book.rating);
// }

// Для того чтобы сократить количество повторений можно деструктуризировать свойства объекта в локальные переменные в теле цикла.

// for (const book of books) {
//     const { title, author, rating } = book;

//     console.log(title);
//     console.log(author);
//     console.log(rating);
//   }

// Если в объекте немного свойств, деструктуризацию можно выполнить прямо в месте объявления переменной book.

// for (const { title, author, rating } of books) {
//   console.log(title);
//   console.log(author);
//   console.log(rating);
// }

// ?--------------------------------------------Глубокая деструктуризация--------------------------------------

// Для деструктуризации свойств вложенных объектов используются те же принципы, что и в трёх предыдущих упражнениях.

// const user = {
//   name: "Jacques Gluke",
//   tag: "jgluke",
//   stats: {
//     followers: 5603,
//     views: 4827,
//     likes: 1308,
//   },
// };

// const {
//   name,
//   tag,
//   stats: { followers, views: userViews, likes: userLikes = 0 },
// } = user;

// console.log(name); // Jacques Gluke
// console.log(tag); // jgluke
// console.log(followers); // 5603
// console.log(userViews); // 4827
// console.log(userLikes); // 1308
